# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...errors.bad_request_error import BadRequestError
from ...errors.forbidden_error import ForbiddenError
from ...errors.internal_server_error import InternalServerError
from ...errors.not_found_error import NotFoundError
from ...types.forbidden_error_body import ForbiddenErrorBody
from .types.list_response_item import ListResponseItem
from .types.delete_folder_response import DeleteFolderResponse
from .types.delete_rule_response import DeleteRuleResponse
from .types.import_rule_response import ImportRuleResponse
from .types.list_folders_response_item import ListFoldersResponseItem
from .types.list_rules_response_item import ListRulesResponseItem
from .types.upsert_folder_response import UpsertFolderResponse
from .types.usage_response import UsageResponse

from ...forge import Rule

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class AssetsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def delete_rule(self, *, id: typing.Optional[str] = OMIT) -> DeleteRuleResponse:
        """
        Delete a specific rule by its ID.

        Parameters:
            - id: typing.Optional[str]. The ID of the rule to delete.
        ---
        from rulebricks.client import RulebricksApi

        client = RulebricksApi(
            api_key="YOUR_API_KEY",
            base_url="https://yourhost.com",
        )
        client.assets.delete_rule()
        """
        _request: typing.Dict[str, typing.Any] = {}
        if id is not OMIT:
            _request["id"] = id
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/admin/rules/delete"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DeleteRuleResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def export_rule(self, *, id: str) -> typing.Dict[str, typing.Any]:
        """
        Export a specific rule by its ID.

        Parameters:
            - id: str. The ID of the rule to export.
        ---
        from rulebricks.client import RulebricksApi

        client = RulebricksApi(
            api_key="YOUR_API_KEY",
            base_url="https://yourhost.com",
        )
        client.assets.export_rule(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/admin/rules/export"),
            params=remove_none_from_dict({"id": id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def import_rule(
        self,
        *,
        rule: Rule,
        publish: typing.Optional[bool] = False,
    ) -> ImportRuleResponse:
        """
        Import a rule into the user's account.

        Parameters:
            - rule: typing.Union[Rule, typing.Dict[str, typing.Any]].
        ---
        import datetime

        from rulebricks.client import RulebricksApi
        from rulebricks.forge import Rule

        client = RulebricksApi(
            api_key="YOUR_API_KEY",
            base_url="https://yourhost.com",
        )

        rule = Rule()
        # Define your rule...

        client.assets.import_rule(rule)
        """
        rule_dict = rule.to_dict()

        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/admin/rules/import"),
            json=jsonable_encoder({
                "id": rule_dict["id"],
                "createdAt": rule_dict["createdAt"],
                "slug": rule_dict["slug"],
                "updatedAt": rule_dict["updatedAt"],
                "testRequest": rule_dict["testRequest"],
                "name": rule_dict["name"],
                "description": rule_dict["description"],
                "requestSchema": rule_dict["requestSchema"],
                "responseSchema": rule_dict["responseSchema"],
                "sampleRequest": rule_dict["sampleRequest"],
                "sampleResponse": rule_dict["sampleResponse"],
                "conditions": rule_dict["conditions"],
                "published": publish,
                "history": rule_dict["history"],
                "groups": rule_dict["groups"],
                "settings": rule_dict["settings"],
                "testSuite": rule_dict["testSuite"],
                "no_conditions": rule_dict["no_conditions"],
            }),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ImportRuleResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ForbiddenErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_rules(self, *, folder: typing.Optional[str] = None) -> typing.List[ListRulesResponseItem]:
        """
        List all rules in the organization. Optionally filter by folder name or ID.

        Parameters:
            - folder: typing.Optional[str]. Filter rules by folder name or folder ID
        ---
        from rulebricks.client import RulebricksApi

        client = RulebricksApi(
            api_key="YOUR_API_KEY",
            base_url="https://yourhost.com/path/to/api",
        )
        client.assets.list_rules()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/admin/rules/list"),
            params=remove_none_from_dict({"folder": folder}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ListRulesResponseItem], _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_flows(self) -> typing.List[ListResponseItem]:
        """
        List all flows in the organization.

        ---
        from rulebricks.client import RulebricksApi

        client = RulebricksApi(
            api_key="YOUR_API_KEY",
            base_url="https://yourhost.com",
        )
        print(client.assets.list_flows())
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/admin/flows/list"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ListResponseItem], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def usage(self) -> UsageResponse:
        """
        Get the rule execution usage of your organization.

        ---
        from rulebricks.client import RulebricksApi

        client = RulebricksApi(
            api_key="YOUR_API_KEY",
            base_url="https://yourhost.com",
        )
        client.assets.usage()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/admin/usage"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UsageResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_folders(self) -> typing.List[ListFoldersResponseItem]:
        """
        Retrieve all rule folders for the authenticated user.

        ---
        from rulebricks.client import RulebricksApi

        client = RulebricksApi(
            api_key="YOUR_API_KEY",
            base_url="https://yourhost.com/path/to/api",
        )
        client.assets.list_folders()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/admin/folders"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ListFoldersResponseItem], _response.json())  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def upsert_folder(
        self, *, id: typing.Optional[str] = OMIT, name: str, description: typing.Optional[str] = OMIT
    ) -> UpsertFolderResponse:
        """
        Create a new rule folder or update an existing one for the authenticated user.

        Parameters:
            - id: typing.Optional[str]. Folder ID (required for updates, omit for creation)

            - name: str. Name of the folder

            - description: typing.Optional[str]. Description of the folder
        ---
        from rulebricks.client import RulebricksApi

        client = RulebricksApi(
            api_key="YOUR_API_KEY",
            base_url="https://yourhost.com/path/to/api",
        )
        client.assets.upsert_folder(
            name="Marketing Rules",
            description="Rules for marketing automation workflows",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"name": name}
        if id is not OMIT:
            _request["id"] = id
        if description is not OMIT:
            _request["description"] = description
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/admin/folders"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UpsertFolderResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_folder(self, *, id: str) -> DeleteFolderResponse:
        """
        Delete a specific rule folder for the authenticated user. This does not delete the rules within the folder.

        Parameters:
            - id: str. ID of the folder to delete
        ---
        from rulebricks.client import RulebricksApi

        client = RulebricksApi(
            api_key="YOUR_API_KEY",
            base_url="https://yourhost.com/path/to/api",
        )
        client.assets.delete_folder(
            id="abc123",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/admin/folders"),
            json=jsonable_encoder({"id": id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DeleteFolderResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncAssetsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def delete_rule(self, *, id: typing.Optional[str] = OMIT) -> DeleteRuleResponse:
        """
        Delete a specific rule by its ID.

        Parameters:
            - id: typing.Optional[str]. The ID of the rule to delete.
        ---
        from rulebricks.client import AsyncRulebricksApi

        client = AsyncRulebricksApi(
            api_key="YOUR_API_KEY",
            base_url="https://yourhost.com",
        )
        await client.assets.delete_rule()
        """
        _request: typing.Dict[str, typing.Any] = {}
        if id is not OMIT:
            _request["id"] = id
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/admin/rules/delete"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DeleteRuleResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def export_rule(self, *, id: str) -> typing.Dict[str, typing.Any]:
        """
        Export a specific rule by its ID.

        Parameters:
            - id: str. The ID of the rule to export.
        ---
        from rulebricks.client import AsyncRulebricksApi

        client = AsyncRulebricksApi(
            api_key="YOUR_API_KEY",
            base_url="https://yourhost.com",
        )
        await client.assets.export_rule(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/admin/rules/export"),
            params=remove_none_from_dict({"id": id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def import_rule(
        self,
        *,
        rule: Rule,
        publish: typing.Optional[bool] = False,
    ) -> ImportRuleResponse:
        """
        Import a rule into the user's account.

        Parameters:
            - rule: typing.Union[Rule, typing.Dict[str, typing.Any]].
        ---
        import datetime

        from rulebricks.client import RulebricksApi
        from rulebricks.forge import Rule

        client = RulebricksApi(
            api_key="YOUR_API_KEY",
            base_url="https://yourhost.com",
        )

        rule = Rule()
        # Define your rule...

        await client.assets.import_rule(rule)
        """
        rule_dict = rule.to_dict()

        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/admin/rules/import"),
            json=jsonable_encoder({
                "id": rule_dict["id"],
                "createdAt": rule_dict["createdAt"],
                "slug": rule_dict["slug"],
                "updatedAt": rule_dict["updatedAt"],
                "testRequest": rule_dict["testRequest"],
                "name": rule_dict["name"],
                "description": rule_dict["description"],
                "requestSchema": rule_dict["requestSchema"],
                "responseSchema": rule_dict["responseSchema"],
                "sampleRequest": rule_dict["sampleRequest"],
                "sampleResponse": rule_dict["sampleResponse"],
                "conditions": rule_dict["conditions"],
                "published": publish,
                "history": rule_dict["history"],
                "groups": rule_dict["groups"],
                "settings": rule_dict["settings"],
                "testSuite": rule_dict["testSuite"],
                "no_conditions": rule_dict["no_conditions"],
            }),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )

        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ImportRuleResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ForbiddenErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_rules(self, *, folder: typing.Optional[str] = None) -> typing.List[ListRulesResponseItem]:
        """
        List all rules in the organization. Optionally filter by folder name or ID.

        Parameters:
            - folder: typing.Optional[str]. Filter rules by folder name or folder ID
        ---
        from rulebricks.client import AsyncRulebricksApi

        client = AsyncRulebricksApi(
            api_key="YOUR_API_KEY",
            base_url="https://yourhost.com/path/to/api",
        )
        await client.assets.list_rules()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/admin/rules/list"),
            params=remove_none_from_dict({"folder": folder}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ListRulesResponseItem], _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_flows(self) -> typing.List[ListResponseItem]:
        """
        List all flows in the organization.

        ---
        from rulebricks.client import AsyncRulebricksApi

        client = AsyncRulebricksApi(
            api_key="YOUR_API_KEY",
            base_url="https://yourhost.com",
        )
        await client.assets.list_flows()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/admin/flows/list"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ListResponseItem], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def usage(self) -> UsageResponse:
        """
        Get the rule execution usage of your organization.

        ---
        from rulebricks.client import AsyncRulebricksApi

        client = AsyncRulebricksApi(
            api_key="YOUR_API_KEY",
            base_url="https://yourhost.com",
        )
        await client.assets.usage()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/admin/usage"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UsageResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_folders(self) -> typing.List[ListFoldersResponseItem]:
        """
        Retrieve all rule folders for the authenticated user.

        ---
        from rulebricks.client import AsyncRulebricksApi

        client = AsyncRulebricksApi(
            api_key="YOUR_API_KEY",
            base_url="https://yourhost.com/path/to/api",
        )
        await client.assets.list_folders()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/admin/folders"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ListFoldersResponseItem], _response.json())  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def upsert_folder(
        self, *, id: typing.Optional[str] = OMIT, name: str, description: typing.Optional[str] = OMIT
    ) -> UpsertFolderResponse:
        """
        Create a new rule folder or update an existing one for the authenticated user.

        Parameters:
            - id: typing.Optional[str]. Folder ID (required for updates, omit for creation)

            - name: str. Name of the folder

            - description: typing.Optional[str]. Description of the folder
        ---
        from rulebricks.client import AsyncRulebricksApi

        client = AsyncRulebricksApi(
            api_key="YOUR_API_KEY",
            base_url="https://yourhost.com/path/to/api",
        )
        await client.assets.upsert_folder(
            name="Marketing Rules",
            description="Rules for marketing automation workflows",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"name": name}
        if id is not OMIT:
            _request["id"] = id
        if description is not OMIT:
            _request["description"] = description
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/admin/folders"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UpsertFolderResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_folder(self, *, id: str) -> DeleteFolderResponse:
        """
        Delete a specific rule folder for the authenticated user. This does not delete the rules within the folder.

        Parameters:
            - id: str. ID of the folder to delete
        ---
        from rulebricks.client import AsyncRulebricksApi

        client = AsyncRulebricksApi(
            api_key="YOUR_API_KEY",
            base_url="https://yourhost.com/path/to/api",
        )
        await client.assets.delete_folder(
            id="abc123",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/admin/folders"),
            json=jsonable_encoder({"id": id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DeleteFolderResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
